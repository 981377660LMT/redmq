在 Redis Streams 中，`XREADGROUP` 命令用于消费者组从流（Stream）中读取消息。你提供的两段代码片段体现了两种不同的读取模式，核心区别在于 **读取目标** 和 **阻塞行为**。以下是详细对比：

---

### **1. `pending` 模式（读取未确认的 Pending 消息）**

```go
rawReply, err = conn.Do("XREADGROUP", "GROUP", groupID, consumerID, "STREAMS", topic, "0-0")
```

#### **特点**

- **目标消息**：`"0-0"` 表示读取当前消费者组内 **未确认（Pending）的消息**（即已分配给消费者但未被 `XACK` 确认的消息）。
  - 适用于 **重试处理失败的消息**（如消费者崩溃后恢复时重新读取未完成的消息）。
- **阻塞行为**：**非阻塞**，立即返回结果（无论是否有 Pending 消息）。
- **典型场景**：
  - 消费者重启后，优先处理之前未确认的消息。
  - 避免消息因未确认而堆积在 Pending 列表中。

---

### **2. 非 `pending` 模式（读取新消息）**

```go
rawReply, err = conn.Do("XREADGROUP", "GROUP", groupID, consumerID, "BLOCK", timeoutMiliSeconds, "STREAMS", topic, ">")
```

#### **特点**

- **目标消息**：`">"` 表示读取 **尚未分配给任何消费者的新消息**。
  - 消息一旦被读取，会被标记为 Pending 状态，直到消费者显式确认（`XACK`）。
- **阻塞行为**：**阻塞等待新消息**（通过 `BLOCK` 参数指定超时时间 `timeoutMiliSeconds`）。
  - 若超时时间内有新消息到达，立即返回；否则超时后返回空。
- **典型场景**：
  - 消费者正常运行时，持续监听并处理新消息。
  - 支持高吞吐实时消息处理。

---

### **关键对比表**

| 特征             | `pending` 模式 (`"0-0"`)      | 非 `pending` 模式 (`">"`)          |
| ---------------- | ----------------------------- | ---------------------------------- |
| **目标消息**     | 未确认的 Pending 消息         | 未被任何消费者读取的新消息         |
| **阻塞行为**     | 非阻塞，立即返回              | 阻塞等待新消息，直到超时或消息到达 |
| **消息状态变更** | 读取后消息仍保持 Pending 状态 | 读取后消息标记为 Pending 状态      |
| **典型用途**     | 重试失败消息、避免消息丢失    | 实时处理新消息                     |
| **消费者组协同** | 处理历史遗留消息              | 协同分配新消息                     |

---

### **示例流程**

1. **消费者启动时**：

   - 先调用 `pending` 模式（`"0-0"`）读取未确认的 Pending 消息，确保历史任务完成。
   - 处理完 Pending 消息后，再切换到非 `pending` 模式（`">"`）监听新消息。

2. **消息处理逻辑**：
   - 消费者读取到消息后，需显式调用 `XACK` 确认消息，否则消息会一直留在 Pending 列表。
   - 若消费者崩溃，未确认的消息会被其他消费者（或恢复后的自身）通过 `pending` 模式重新读取。

---

### **注意事项**

- **避免消息循环重试**：若消息处理逻辑存在永久性错误，需设计死信队列（Dead-Letter Queue）机制，防止 Pending 消息无限重试。
- **合理配置超时**：非 `pending` 模式的 `BLOCK` 超时时间需根据业务实时性要求调整，避免阻塞过久影响系统响应。
- **消费者负载均衡**：同一消费者组内，新消息会自动分配给空闲的消费者，确保负载均衡（类似 Kafka 的分区分配机制）。

---

通过区分这两种模式，Redis Streams 实现了 **消息的可靠处理**（Pending 重试）和 **实时监听**（新消息消费），是构建健壮消息系统的关键机制。
